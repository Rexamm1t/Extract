import random
import json
import time
import os
import textwrap
from datetime import datetime, timedelta
from colorama import Fore, Style, init

ADDINFO = "EXTRACT‚Ñ¢ PLATFORM 2025"
INFO = "Extract Team (Rexamm1t, Wefol1x)"
VERSION = "EXTRACT 10.2.6"
VERSION_ALL = "EXTRACT 10.2.6 (7.7.25)"

SAVE_PATH = "data/users.json"
KEYS_PATH = "data/keys.json"
RECEIPTS_PATH = "logs/receipts.json"
CS_LOG_PATH = "logs/cs_l.json"
FORUM_PATH = "forum/meta.json"

CRYPTO_SYMBOLS = {
    "EXTRACT": "‚í∫",
    "BETASTD": "Œ≤",
    "EXRSD": "ƒí",
    "DOGCOIN": "DC",
    "BTC": "‚Çø",
    "ETH": "Œû",
    "LTC": "≈Å",
    "BNB": "Íûç",
    "ADA": "ùî∏",
    "SOL": "S",
    "XRP": "‚úï",
    "DOT": "‚óè",
    "DOGE": "√ê",
    "SHIB": "SH",
    "AVAX": "AV",
    "TRX": "T",
    "MATIC": "M",
    "ATOM": "A",
    "NOT": "‚ñ≤",
    "TON": "‚ñº",
    "XYZ": "≈∏",
    "ABC": "‚ú¶",
    "DEF": "DT",
    "GHI": "ƒû",
    "JKL": "+",
    "MNO": "·∏æ",
    "PQR": "‚ùñ"
}
CURRENCY = "‚í∫"
INITIAL_BALANCE = 10000.0
LEVEL_BASE_XP = 1000

AUTOSAVE_INTERVAL = 300

MONTHLY_EVENTS = {
    1: {
        "name": "‚ùÑÔ∏è –ù–æ–≤–æ–≥–æ–¥–Ω–∏–π –†–∞–∑–≥–æ–Ω",
        "effects": {
            "slots_multiplier": 1.8,
            "free_daily_spins": 3,
            "level_up_bonus": 2000
        }
    },
    2: {
        "name": "üíò –ë–∏—Ç–≤–∞ –°–µ—Ä–¥–µ—Ü",
        "effects": {
            "double_win_chance": True,
            "referral_bonus": 1.5,
            "loss_protection": 0.25
        }
    },
    3: {
        "name": "üå± –í–µ—Å–µ–Ω–Ω–∏–π –†–æ—Å—Ç",
        "effects": {
            "xp_boost": 2.0,
            "trade_xp_bonus": 3,
            "daily_interest": 0.01
        }
    },
    4: {
        "name": "üå∏ –ê–ø—Ä–µ–ª—å—Å–∫–∏–π –õ–æ—Ç–µ—Å",
        "effects": {
            "jackpot_chance": 0.15,
            "insurance": 0.2,
            "daily_bonus": 1500
        }
    },
    5: {
        "name": "‚ö° –ú–∞–π—Å–∫–∏–π –®—Ç—É—Ä–º",
        "effects": {
            "battle_xp": 1.8,
            "daily_gift": 1500,
            "free_spins": 2
        }
    },
    6: {
        "name": "üåû –õ–µ—Ç–Ω–∏–π –ö—Ä—É–∏–∑",
        "effects": {
            "trade_fee": 0.7,
            "slots_bonus": 3000,
            "xp_multiplier": 1.4
        }
    },
    7: {
        "name": "üî• –ñ–∞—Ä–∫–∏–π –£–¥–∞—Ä",
        "effects": {
            "xp_multiplier": 1.4,
            "free_spins": 3,
            "daily_interest": 0.015
        }
    },
    8: {
        "name": "üå™Ô∏è –ê–≤–≥—É—Å—Ç–æ–≤—Å–∫–∏–π –í–µ—Ç–µ—Ä",
        "effects": {
            "win_multiplier": 1.25,
            "insurance": 0.25,
            "trade_bonus": 1.1
        }
    },
    9: {
        "name": "üçÇ –û—Å–µ–Ω–Ω–∏–π –£—Ä–æ–∂–∞–π",
        "effects": {
            "trade_bonus": 1.3,
            "daily_gift": 2000,
            "xp_boost": 1.5
        }
    },
    10: {
        "name": "üéÉ –•–µ–ª–ª–æ—É–∏–Ω –°–ø–µ—à–∏–∞–ª",
        "effects": {
            "jackpot_chance": 0.2,
            "battle_xp": 2.0,
            "mystery_gift": True
        }
    },
    11: {
        "name": "üåßÔ∏è –ù–æ—è–±—Ä—å—Å–∫–∏–π –®—Ç–æ—Ä–º",
        "effects": {
            "xp_multiplier": 1.6,
            "slots_bonus": 4000,
            "loss_protection": 0.3
        }
    },
    12: {
        "name": "üéÑ –ó–∏–º–Ω–µ–µ –ß—É–¥–æ",
        "effects": {
            "win_multiplier": 1.5,
            "year_end_special": True,
            "unlimited_withdrawals": True
        }
    }
}

init(autoreset=True)

def dynamic_border(text, border_color=Fore.MAGENTA, width=None):
    lines = text.split('\n')
    max_width = width if width else max(len(line) for line in lines) + 4
    border = '‚ïê' * (max_width - 2)
    bordered = [f"{border_color}‚ïî{border}‚ïó"]
    for line in lines:
        bordered.append(f"{border_color}‚ïë {line.ljust(max_width - 4)} ‚ïë")
    bordered.append(f"{border_color}‚ïö{border}‚ïù")
    return '\n'.join(bordered)

def rainbow_text(text):
    colors = [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.BLUE, Fore.MAGENTA]
    return ''.join([colors[i % len(colors)] + char for i, char in enumerate(text)])

def gradient_text(text, colors):
    return ''.join([colors[i % len(colors)] + char for i, char in enumerate(text)])

def format_time(seconds):
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    seconds = seconds % 60
    return f"{int(hours)}—á {int(minutes)}–º {int(seconds)}—Å"

def print_art():
    art = r"""
      ___           ___           ___           ___           ___           ___           ___     
     /\  \         |\__\         /\  \         /\  \         /\  \         /\  \         /\  \    
    /::\  \        |:|  |        \:\  \       /::\  \       /::\  \       /::\  \        \:\  \   
   /:/\:\  \       |:|  |         \:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \        \:\  \  
  /::\~\:\  \      |:|__|__       /::\  \   /::\~\:\  \   /::\~\:\  \   /:/  \:\  \       /::\  \ 
 /:/\:\ \:\__\ ____/::::\__\     /:/\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ /:/__/ \:\__\     /:/\:\__\
 \:\~\:\ \/__/ \::::/~~/~       /:/  \/__/ \/_|::\/:/  / \/__\:\/:/  / \:\  \  \/__/    /:/  \/__/
  \:\ \:\__\    ~~|:|~~|       /:/  /         |:|::/  /       \::/  /   \:\  \         /:/  /     
   \:\ \/__/      |:|  |       \/__/          |:|\/__/        /:/  /     \:\  \        \/__/      
    \:\__\        |:|  |                      |:|  |         /:/  /       \:\__\                  
     \/__/         \|__|                       \|__|         \/__/         \/__/                  
    """
    print(gradient_text(art, [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.BLUE, Fore.MAGENTA]))

class CryptoMarket:
    def __init__(self):
        self.rates = {
            "BETASTD": random.uniform(7750100, 10000000),
            "DOGCOIN": random.uniform(1000000, 2000000),
            "EXRSD": random.uniform(328110, 400000),
            "BTC": random.uniform(25000, 110000),
            "ETH": random.uniform(1500, 6000),
            "LTC": random.uniform(60, 455),
            "BNB": random.uniform(200, 600),
            "ADA": random.uniform(200, 500),
            "SOL": random.uniform(20, 200),
            "XRP": random.uniform(50, 100),
            "DOT": random.uniform(4, 300),
            "DOGE": random.uniform(300, 500),
            "SHIB": random.uniform(1000, 20000),
            "AVAX": random.uniform(10, 100),
            "TRX": random.uniform(100, 200),
            "MATIC": random.uniform(14000, 16000),
            "ATOM": random.uniform(600, 1000),
            "NOT": random.uniform(0.05, 0.5),
            "TON": random.uniform(1.0, 6.5),
            "XYZ": random.uniform(0.01, 0.1),
            "ABC": random.uniform(10, 50),
            "DEF": random.uniform(100, 500),
            "GHI": random.uniform(5, 20),
            "JKL": random.uniform(0.001, 0.01),
            "MNO": random.uniform(0.5, 2),
            "PQR": random.uniform(1000, 5000),
            "EXTRACT": 1.0
        }

    def update_rates(self):
        for coin in self.rates:
            if coin != "EXTRACT":
                change = random.uniform(-0.07, 0.07)
                self.rates[coin] = max(0.01, self.rates[coin] * (1 + change))

    def get_rate(self, coin):
        return self.rates.get(coin, 0.0)

    def save_rates(self):
        try:
            os.makedirs(os.path.dirname(CS_LOG_PATH), exist_ok=True)
            with open(CS_LOG_PATH, "w") as f:
                json.dump(self.rates, f, indent=4)
        except Exception as e:
            print(f"{Fore.YELLOW}–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫—É—Ä—Å—ã: {str(e)}")

    def update_rates(self):
        old_rates = self.rates.copy()
        for coin in self.rates:
            if coin != "EXTRACT":
                change = random.uniform(-0.07, 0.07)
                self.rates[coin] = max(0.01, self.rates[coin] * (1 + change))
        self.save_rates()
        return old_rates

class Forum:
    def __init__(self):
        self.messages = []
        self.load_messages()

    def load_messages(self):
        try:
            os.makedirs(os.path.dirname(FORUM_PATH), exist_ok=True)
            if not os.path.exists(FORUM_PATH):
                default_messages = [{
                    "id": 1,
                    "title": "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ EXTRACT!",
                    "content": "–≠—Ç–æ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π —Ñ–æ—Ä—É–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. –ó–¥–µ—Å—å –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –≤–∞–∂–Ω—ã–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è.",
                    "author": "Extract Team",
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "pinned": True
                }]
                with open(FORUM_PATH, 'w', encoding='utf-8') as f:
                    json.dump(default_messages, f, indent=4)
            
            with open(FORUM_PATH, 'r', encoding='utf-8') as f:
                self.messages = json.load(f)
        except Exception as e:
            print(f"{Fore.YELLOW}–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ä—É–º–∞: {str(e)}")
            self.messages = []

    def show_forum(self, limit=5):
        pinned = [m for m in self.messages if m.get("pinned", False)]
        regular = [m for m in self.messages if not m.get("pinned", False)]
        messages = (pinned + regular)[:limit]
        
        if not messages:
            print(dynamic_border(f"{Fore.YELLOW}–ù–∞ —Ñ–æ—Ä—É–º–µ –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π", Fore.YELLOW))
            return

        content = [
            f"{Fore.RED}‚ïî{'‚ïê'*50}‚ïó",
            f"‚ïë{'EXTRAFORUM'.center(50)}‚ïë",
            f"‚ï†{'‚ïê'*50}‚ï£"
        ]

        for msg in messages:
            pin = "üìå " if msg.get("pinned", False) else ""
            content.append(f"‚ïë {pin}{Fore.YELLOW}{msg['title'].ljust(48)}‚ïë")
            content.append(f"‚ïë {Fore.WHITE}–ê–≤—Ç–æ—Ä: {msg.get('author', 'Extract Team')} | –î–∞—Ç–∞: {msg.get('date', 'N/A')} ‚ïë")
            content.append(f"‚ï†{'‚îÄ'*50}‚ï£")
            
            # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –ø–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
            for line in textwrap.wrap(msg['content'], width=48):
                content.append(f"‚ïë {Fore.GREEN}{line.ljust(48)}‚ïë")
            
            content.append(f"‚ï†{'‚ïê'*50}‚ï£")

        print('\n'.join(content))

class User:
    def __init__(self, username):
        self.username = username
        self.crypto_balance = {coin: 0.0 for coin in CRYPTO_SYMBOLS}
        self.crypto_balance["EXTRACT"] = INITIAL_BALANCE
        self.games_played = 0
        self.wins = 0
        self.losses = 0
        self.transactions = []
        self.total_earned = 0.0
        self.play_time = 0.0
        self.session_start = None
        self.level = 1
        self.xp = 0
        self.total_earned = 0.0
        self.subscription = {"type": "none", "expires_at": None, "autorenew": False}
        self.last_login = None
        self.free_spins = 0
        self.consecutive_wins = 0
        self.last_action_time = None

    def to_dict(self):
        return {
            "username": self.username,
            "crypto_balance": self.crypto_balance,
            "games_played": self.games_played,
            "wins": self.wins,
            "losses": self.losses,
            "transactions": self.transactions,
            "play_time": self.play_time,
            "level": self.level,
            "xp": self.xp,
            "total_earned": self.total_earned,
            "subscription": self.subscription,
            "last_login": self.last_login,
            "free_spins": self.free_spins,
            "consecutive_wins": self.consecutive_wins
        }

    @classmethod
    def from_dict(cls, data):
        user = cls(data["username"])
        user.crypto_balance = {coin: data["crypto_balance"].get(coin, 0.0) for coin in CRYPTO_SYMBOLS}
        user.games_played = data.get("games_played", 0)
        user.wins = data.get("wins", 0)
        user.losses = data.get("losses", 0)
        user.transactions = data.get("transactions", [])
        user.play_time = data.get("play_time", 0.0)
        user.level = data.get("level", 1)
        user.xp = data.get("xp", 0)
        user.total_earned = data.get("total_earned", 0.0)
        user.subscription = data.get("subscription", {"type": "none", "expires_at": None, "autorenew": False})
        user.last_login = data.get("last_login", None)
        user.free_spins = data.get("free_spins", 0)
        user.consecutive_wins = data.get("consecutive_wins", 0)
        return user

    def start_session(self):
        self.session_start = time.time()

    def end_session(self):
        if self.session_start:
            self.play_time += time.time() - self.session_start
            self.session_start = None

    def update_stats(self, won):
        self.games_played += 1
        if won:
            self.wins += 1
        else:
            self.losses += 1

    def add_transaction(self, action, coin, amount, price):
        self.transactions.insert(0, {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "action": action,
            "coin": coin,
            "amount": round(amount, 4),
            "total": round(price, 2)
        })
        self.transactions = self.transactions[:10]

    def win_loss_ratio(self):
        if self.games_played == 0:
            return 0.0
        return round(self.wins / self.games_played * 100, 1)

    def add_xp(self, amount):
        xp_gain = amount
        if self.subscription["type"] == "eup":
            xp_gain *= 1.2
        elif self.subscription["type"] == "eup_plus":
            xp_gain *= 1.5

        self.xp += xp_gain
        while self.xp >= self.required_xp():
            self.xp -= self.required_xp()
            self.level_up()

    def required_xp(self):
        base = LEVEL_BASE_XP * 5
        return int(base * (self.level ** 2.2 + self.level * 8))

    def level_up(self):
        self.level += 1
        reward = self.level * 1000
        self.crypto_balance["EXTRACT"] += reward
        print(dynamic_border(
            f"{Fore.GREEN}üéâ –£—Ä–æ–≤–µ–Ω—å –ü–æ–≤—ã—à–µ–Ω! {self.level-1} => {self.level}\n"
            f"+{reward}{CURRENCY} - –í–∞—à –±–æ–Ω—É—Å –∑–∞ —É—Ä–æ–≤–µ–Ω—å!\n"
            f"–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å: {self.required_xp():.0f} XP",
            Fore.YELLOW
        ))

    def show_level_progress(self):
        req = self.required_xp()
        progress = min(1.0, self.xp / req)
        gradient = [Fore.RED, Fore.YELLOW, Fore.GREEN]
        color = gradient[min(2, int(progress * 3))]
        
        bar = "‚ñì" * int(progress * 20) + "‚ñë" * (20 - int(progress * 20))
        return f"{Fore.CYAN}{bar} {progress*100:.1f}%"

    def crywall(self):
        content = [f"{Fore.CYAN}‚ïî{'‚ïê'*25}‚ï¶{'‚ïê'*15}‚ïó"]
        for coin, amount in self.crypto_balance.items():
            if amount <= 0: continue
            symbol = CRYPTO_SYMBOLS[coin]
            line = f"‚ïë {symbol} {coin.ljust(10)} ‚ïë {amount:>10.4f} ‚ïë"
            color = Fore.GREEN if coin == "EXTRACT" else Fore.YELLOW
            content.append(color + line)
        content.append(f"{Fore.CYAN}‚ïö{'‚ïê'*25}‚ï©{'‚ïê'*15}‚ïù")
        print('\n'.join(content))

    def show_stats(self):
        THEME = {
            'eup': Fore.CYAN,
            'eup_plus': Fore.YELLOW,
            'base': Fore.GREEN,
            'stats': Fore.MAGENTA,
            'transactions': Fore.WHITE
        }

        if self.has_active_subscription():
            expiry_date = datetime.strptime(self.subscription["expires_at"], "%Y-%m-%d")
            days_left = (expiry_date - datetime.now()).days
            sub_icon = "üî∑" if self.subscription["type"] == "eup" else "üî∂"
            sub_color = THEME[self.subscription["type"]]
    
            sub_header = f"{sub_icon} {sub_color}{self.subscription['type'].upper()}"
            sub_details = [
                f"  {sub_color}–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: {expiry_date.strftime('%d.%m.%Y')}",
                f"  {sub_color}–û—Å—Ç–∞–ª–æ—Å—å: {days_left} –¥–Ω–µ–π",
                f"  {sub_color}–ë–æ–Ω—É—Å—ã: +{25 if self.subscription['type'] == 'eup_plus' else 10}% –≤—ã–∏–≥—Ä—ã—à–∏, "
                f"{20 if self.subscription['type'] == 'eup_plus' else 10}% —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞"
            ]
        else:
            sub_header = f"‚ö™ {Fore.RED}–ë–ï–ó –ü–û–î–ü–ò–°–ö–ò"
            sub_details = [
                f"  {Fore.RED}–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏:",
                f"> {Fore.CYAN}EUP  - 10 BTC/–¥–µ–Ω—å",
                f"> {Fore.YELLOW}EUP+ - 15 BTC/–¥–µ–Ω—å + –±–æ–Ω—É—Å—ã"
            ]

        profile = [
            f"{THEME['base']}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ",
            f"‚îÇ        {Fore.WHITE}    –ü–æ–¥–ø–∏—Å–∫–∞             {THEME['base']}‚îÇ",
            f"‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|",
            f"    {sub_header.ljust(30)}{THEME['base']}",
            *sub_details,
            f"{THEME['base']}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ",
            f"‚îÇ        {Fore.WHITE}   –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞            {THEME['base']}‚îÇ",
            f"‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|",
            f"  {Fore.YELLOW}–ë–∞–ª–∞–Ω—Å: {self.crypto_balance['EXTRACT']:,.2f} {CURRENCY}\n",
            f"  {THEME['stats']}WLR: {self.win_loss_ratio()}%           ",
            f"  {THEME['stats']}–ò–≥—Ä: {self.games_played}  üèÜ {self.wins}  üíÄ {self.losses}\n",
            f"{THEME['base']} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ \n",
            f"  {THEME['stats']}–£—Ä–æ–≤–µ–Ω—å: {self.level:<2}\n",
            f"  {THEME['stats']}{self.show_level_progress()}\n"
        ]

        top_coins = sorted(
            [(k, v) for k, v in self.crypto_balance.items() if v > 0 and k != "EXTRACT"],
            key=lambda x: x[1],
            reverse=True
        )[:3]

        if top_coins:
            profile.extend([
                f"{THEME['base']}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ",
                f"‚îÇ        {Fore.WHITE}   –¢–æ–ø –∞–∫—Ç–∏–≤—ã            {THEME['base']}‚îÇ",
                f"‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|",
            ])
            for coin, amount in top_coins:
                profile.append(f"  {THEME['stats']}  {CRYPTO_SYMBOLS[coin]} {coin}: {amount:>12.2f}  {THEME['base']} ")

        if self.transactions:
            profile.extend([
                f"{THEME['base']}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ",
                f"‚îÇ       {Fore.WHITE}–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏      {THEME['base']}‚îÇ",
                f"‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|",
            ])
            for t in self.transactions[:6]:
                if t['action'] in ['buy', 'sell']:
                    action_icon = "+" if t['action'] == 'buy' else "-"
                    action_color = Fore.GREEN if t['action'] == 'buy' else Fore.RED
                    profile.append(
                        f"  {action_icon} {t['timestamp'][5:16]} "
                        f"{action_color}{t['action'].upper()} {t['amount']:.2f} {t['coin']} "
                        f"{THEME['transactions']}–∑–∞ {t['total']}{CURRENCY} {THEME['base']} "
                    )
                elif t['action'] == 'transfer_in':
                    profile.append(
                        f"  + {t['timestamp'][5:16]} "
                        f"{Fore.GREEN}–ü–æ–ª—É—á–µ–Ω–æ (–ø–µ—Ä–µ–≤–æ–¥) {t['amount']:.2f} {t['coin']} "
                        f"{THEME['transactions']}–æ—Ç {t['from']} {THEME['base']} "
                    )
                elif t['action'] == 'transfer_out':
                    profile.append(
                        f"  - {t['timestamp'][5:16]} "
                        f"{Fore.RED}–ü–µ—Ä–µ–≤–µ–¥–µ–Ω–æ {t['amount']:.2f} {t['coin']} "
                        f"{THEME['transactions']}–∫–æ–º–∏—Å—Å–∏—è: {t['commission']:.2f} {THEME['base']} "
                    )

        profile.append(f" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ")
        print('\n'.join(profile))

    def has_active_subscription(self):
        if self.subscription["type"] == "none":
            return False
        if self.subscription["expires_at"] is None:
            return False
        expiry_date = datetime.strptime(self.subscription["expires_at"], "%Y-%m-%d")
        return datetime.now() <= expiry_date
    
    def get_styled_username(self):
        if not self.has_active_subscription():
            return self.username
        if self.subscription["type"] == "eup":
            return f"{Style.BRIGHT}{Fore.CYAN}{self.username}{Style.RESET_ALL}"
        return f"{Style.BRIGHT}{Fore.YELLOW}{self.username}{Style.RESET_ALL}"
    
    def give_daily_bonus(self):
        today = datetime.now().strftime("%Y-%m-%d")
        if self.last_login == today:
            return
        
        self.last_login = today
        
        if self.subscription["type"] == "eup":
            bonus = 1000000
            self.crypto_balance["EXTRACT"] += bonus
            print(dynamic_border(f"{Fore.CYAN}–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å EUP: +1,000,000‚í∫", Fore.CYAN))
        
        elif self.subscription["type"] == "eup_plus":
            bonus = 10000000
            self.crypto_balance["EXTRACT"] += bonus
            print(dynamic_border(f"{Fore.YELLOW}–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å EUP+: +2,000,000‚í∫", Fore.YELLOW))
            
            if random.random() < 0.05:
                btc_bonus = 10.0
                self.crypto_balance["BTC"] = self.crypto_balance.get("BTC", 0) + btc_bonus
                print(dynamic_border(f"{Fore.GREEN}–°–£–ü–ï–†–ë–û–ù–£–°! +10 ‚Çø", Fore.GREEN))
    
    def check_subscription(self):
        if not self.has_active_subscription():
            self.subscription = {"type": "none", "expires_at": None, "autorenew": False}
    
    def buy_eup(self, days):
        if not 1 <= days <= 365:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –º–æ–∂–Ω–æ –∫—É–ø–∏—Ç—å –æ—Ç 1 –¥–æ 365 –¥–Ω–µ–π! –ù–µ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ –≥–æ–¥–∞.")
            return
        
        cost = 10 * days
        print(dynamic_border(
            f"{Fore.BLUE}EUP base -------------------- Base\n"
            f"{Fore.CYAN}–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–∫—É–ø–∫—É EUP –Ω–∞ {days} –¥–Ω–µ–π\n"
            f"–°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} ‚Çø\n"
            f"–í–∞—à –±–∞–ª–∞–Ω—Å BTC: {self.crypto_balance.get('BTC', 0):.8f} ‚Çø\n\n"
            f"{Fore.YELLOW}–í–≤–µ–¥–∏—Ç–µ 'yes' –¥–ª—è –æ–ø–ª–∞—Ç—ã:",
            Fore.CYAN
        ))
        
        confirm = input(">>> ").lower()
        if confirm == "yes":
            if self.crypto_balance.get("BTC", 0) >= cost:
                self.crypto_balance["BTC"] -= cost
                expiry_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")
                self.subscription = {"type": "eup", "expires_at": expiry_date, "autorenew": True}
                print(dynamic_border(
                    f"{Fore.GREEN}–û–ø–ª–∞—á–µ–Ω–æ! EUP –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ {expiry_date}\n"
                    f"{Fore.BLUE}–ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –∑–∞ –ø–æ–∫—É–ø–∫—É!\n"
                    f"–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å BTC: {self.crypto_balance['BTC']:.8f} ‚Çø",
                    Fore.GREEN
                ))
            else:
                print(f"{Fore.RED}–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC!")
        else:
            print(f"{Fore.YELLOW}–û—Ç–º–µ–Ω–µ–Ω–æ.")
    
    def buy_eup_plus(self, days):
        if not 1 <= days <= 365:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –º–æ–∂–Ω–æ –∫—É–ø–∏—Ç—å –æ—Ç 1 –¥–æ 365 –¥–Ω–µ–π! –ù–µ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ –≥–æ–¥–∞")
            return
        
        cost = 15 * days
        print(dynamic_border(
            f"{Fore.YELLOW}EUP plus -------------------- Plus\n"
            f"{Fore.YELLOW}–ü–æ–∫—É–ø–∫–∞ EUP+ –Ω–∞ {days} –¥–Ω–µ–π\n"
            f"–°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} ‚Çø\n"
            f"–í–∞—à –±–∞–ª–∞–Ω—Å: {self.crypto_balance.get('BTC', 0):.8f} ‚Çø\n"
            f"{Fore.CYAN}–í–≤–µ–¥–∏—Ç–µ 'yes' –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è:",
            Fore.YELLOW
        ))
        
        if input(">>> ").lower() != "yes":
            print(f"{Fore.YELLOW}–û—Ç–º–µ–Ω–µ–Ω–æ.")
            return
        
        if self.crypto_balance.get("BTC", 0) < cost:
            print(f"{Fore.RED}–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ BTC. –ù—É–∂–Ω–æ: {cost} ‚Çø")
            return
        
        self.crypto_balance["BTC"] -= cost
        expiry = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")
        self.subscription = {
            "type": "eup_plus",
            "expires_at": expiry,
            "autorenew": False
        }
        
        bonus = 2000000
        self.crypto_balance["EXTRACT"] += bonus
        
        print(dynamic_border(
            f"{Fore.GREEN}EUP+ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –¥–æ {expiry}!\n"
            f"+{bonus}‚í∫ –±–æ–Ω—É—Å –∑–∞ –ø–æ–∫—É–ø–∫—É. –ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –∑–∞ –ø–æ–∫—É–ø–∫—É!\n"
            f"–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å BTC: {self.crypto_balance['BTC']:.8f} ‚Çø",
            Fore.GREEN
        ))
    
    def eup_status(self):
        if not self.has_active_subscription():
            print(f"{Fore.RED}–£ –≤–∞—Å –Ω–µ—Ç –Ω–∏–∫–∞–∫–∏—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫.")
            return
        
        remaining = (datetime.strptime(self.subscription["expires_at"], "%Y-%m-%d") - datetime.now()).days
        print(dynamic_border(
            f"{Fore.CYAN}–°—Ç–∞—Ç—É—Å –ü–æ–¥–ø–∏—Å–∫–∏\n"
            f"–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: {self.subscription['expires_at']}\n"
            f"–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π: {remaining}\n"
            f"–ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ: {'–≤–∫–ª' if self.subscription.get('autorenew', False) else '–≤—ã–∫–ª'}\n",
            Fore.CYAN
        ))
    
    def eup_autonone(self):
        if not self.has_active_subscription():
            print(f"{Fore.RED}–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏!")
            return
        
        self.subscription["autorenew"] = False
        print(f"{Fore.GREEN}–ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–æ–∫ –æ—Ç–∫–ª—é—á–µ–Ω–æ. –î–µ–π—Å—Ç–≤—É—é—â–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ—á—ë—Ç {self.subscription['expires_at']}.")

class Casino:
    def __init__(self):
        self.users = {}
        self.current_user = None
        self.market = CryptoMarket()
        self.last_command = ""
        self.last_save = time.time()
        self.promo_codes = self._load_promocodes()
        self.forum = Forum()
        self.load_users()

    def save_users(self):
        try:
            with open(SAVE_PATH, "w") as f:
                data = {un: user.to_dict() for un, user in self.users.items()}
                json.dump(data, f, indent=4)
        except Exception as e:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {str(e)}")

    def load_users(self):
        try:
            with open(SAVE_PATH, "r") as f:
                data = json.load(f)
                self.users = {un: User.from_dict(user_data) for un, user_data in data.items()}
        except (FileNotFoundError, json.JSONDecodeError):
            self.users = {}
        except Exception as e:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {str(e)}")

    def _load_promocodes(self):
        try:
            with open(KEYS_PATH, "r") as f:
                data = json.load(f)
                valid_codes = {}
                for code, details in data.items():
                    if isinstance(details, dict) and all(key in details for key in ['type', 'amount', 'used']):
                        if details['type'] == 'crypto' and 'coin' not in details:
                            continue
                        valid_codes[code.lower()] = details
                return valid_codes
        except FileNotFoundError:
            print(f"{Fore.YELLOW}–§–∞–π–ª –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: {KEYS_PATH}")
            return {}
        except Exception as e:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤: {str(e)}")
            return {}

    def _save_promocodes(self):
        try:
            with open(KEYS_PATH, "w") as f:
                json.dump(self.promo_codes, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤: {str(e)}")

    def activate_promo(self, code):
        if not self.current_user:
            print(dynamic_border(f"{Fore.RED}–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!", Fore.RED))
            return

        code = code.lower()
        promo = self.promo_codes.get(code)

        if not promo:
            print(dynamic_border(f"{Fore.RED}–ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥!", Fore.RED))
            return
            
        if promo["used"]:
            print(dynamic_border(f"{Fore.RED}–ü—Ä–æ–º–æ–∫–æ–¥ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω!", Fore.RED))
            return

        if promo["type"] == "xp":
            self.current_user.add_xp(promo["amount"])
            msg = f"+{promo['amount']} XP"
        elif promo["type"] == "currency":
            self._update_balance(promo["amount"])
            msg = f"+{promo['amount']}{CURRENCY}"
        elif promo["type"] == "eup":
            expiry_date = (datetime.now() + timedelta(days=promo['amount'])).strftime("%Y-%m-%d")
            self.current_user.subscription = {
                "type": "eup",
                "expires_at": expiry_date,
                "autorenew": False
            }
            msg = f"EUP –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {promo['amount']} –¥–Ω–µ–π"

        elif promo["type"] == "eup_plus":
            expiry_date = (datetime.now() + timedelta(days=promo['amount'])).strftime("%Y-%m-%d")
            self.current_user.subscription = {
                "type": "eup_plus",
                "expires_at": expiry_date,
                "autorenew": False
            }
            msg = f"EUP+ –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {promo['amount']} –¥–Ω–µ–π"

        elif promo["type"] == "crypto":
            coin = promo["coin"]
            amount = promo["amount"]
            self.current_user.crypto_balance[coin] += amount
            msg = f"+{amount} {coin} {CRYPTO_SYMBOLS[coin]}"
        else:
            print(dynamic_border(f"{Fore.RED}–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø—Ä–æ–º–æ–∫–æ–¥–∞!", Fore.RED))
            return

        self.promo_codes[code]["used"] = True
        self._save_promocodes()
        
        print(dynamic_border(
            f"{Fore.GREEN}–£—Å–ø–µ—à–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è!\n"
            f"{Fore.CYAN}–ù–∞–≥—Ä–∞–¥–∞: {msg}",
            Fore.GREEN
        ))

    def get_current_event(self):
        current_month = datetime.now().month
        event = MONTHLY_EVENTS.get(current_month, {}).copy()
        if event:
            event["active"] = True
            return event
        return None

    def apply_event_bonus(self, bonus_type, base_value):
        event = self.get_current_event()
        if not event or "effects" not in event:
            return base_value
            
        bonus = event["effects"].get(bonus_type, 1.0)
        
        if isinstance(bonus, (int, float)):
            return base_value * bonus
        elif isinstance(bonus, int):
            return base_value + bonus
        return base_value

    def show_monthly_event(self):
        event = self.get_current_event()
        if not event:
            print(dynamic_border(f"{Fore.YELLOW}–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π", Fore.YELLOW))
            return
        
        month_name = datetime.now().strftime("%B")
        days_left = (datetime.now().replace(day=1) + timedelta(days=32)).replace(day=1) - datetime.now()
        
        content = [
            f"{Fore.MAGENTA}üìÖ {month_name} - {event['name']}",
            f"{Fore.CYAN}–û—Å—Ç–∞–ª–æ—Å—å: {days_left.days} –¥–Ω–µ–π",
            f"{Fore.GREEN}–î–µ–π—Å—Ç–≤—É—é—â–∏–µ –±–æ–Ω—É—Å—ã:",
        ]
        
        bonus_icons = {
            "multiplier": "üìà",
            "bonus": "üéÅ", 
            "special": "‚ú®",
            "protection": "üõ°Ô∏è"
        }
        
        for effect, value in event["effects"].items():
            icon = bonus_icons.get(effect.split('_')[-1], "‚ñ™Ô∏è")
            if isinstance(value, bool):
                content.append(f"{icon} {effect}: {'–ê–∫—Ç–∏–≤–µ–Ω' if value else '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω'}")
            elif isinstance(value, float):
                content.append(f"{icon} {effect}: x{value}")
            else:
                content.append(f"{icon} {effect}: +{value}")
        
        print(dynamic_border('\n'.join(content), Fore.MAGENTA))

    def _check_balance(self, amount, currency="EXTRACT"):
        return self.current_user.crypto_balance.get(currency, 0) >= amount

    def _update_balance(self, amount, currency="EXTRACT"):
        self.current_user.crypto_balance[currency] += amount

    def _validate_bet(self, bet):
        if not self.current_user:
            print(f"{Fore.RED}–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!")
            return False
        if bet <= 0:
            print(f"{Fore.RED}–°—Ç–∞–≤–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π!")
            return False
        if not self._check_balance(bet):
            print(f"{Fore.RED}–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!")
            return False
        return True

    def _process_result(self, win, bet):
        win = self.apply_event_bonus("win_multiplier", win)
        if win > 0:
            self._update_balance(win)
            self.current_user.update_stats(True)
            self.current_user.add_xp(win)
        else:
            self.current_user.update_stats(False)
            self.current_user.add_xp(bet * 0.1)
        self.current_user.total_earned += win
        self.save_users()
    
    def _apply_subscription_bonus(self, win):
        if self.current_user.subscription["type"] == "eup":
            return win * 1.10
        elif self.current_user.subscription["type"] == "eup_plus":
            return win * 1.25
        return win
    
    def _apply_subscription_refund(self, bet):
        if not self.current_user.has_active_subscription():
            return 0
        
        if self.current_user.subscription["type"] == "eup":
            refund = bet * 0.10
            self._update_balance(refund)
            return refund
        
        if self.current_user.subscription["type"] == "eup_plus":
            refund = bet * 0.20
            self._update_balance(refund)
            return refund
        
        return 0

    def create_user(self, username):
        if username in self.users:
            print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
            return
        self.users[username] = User(username)
        self.current_user = self.users[username]
        self.save_users()
        print(f"{gradient_text(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —Å–æ–∑–¥–∞–Ω!', [Fore.GREEN, Fore.LIGHTGREEN_EX])}")

    def select_user(self, username):
        if username in self.users:
            if self.current_user:
                self.current_user.end_session()
            self.current_user = self.users[username]
            self.current_user.start_session()
            self.current_user.check_subscription()
            self.current_user.give_daily_bonus()
            print(f"{Fore.GREEN}–í—ã–±—Ä–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {self.current_user.get_styled_username()}")
        else:
            print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!")

    def delete_user(self, username):
        if username in self.users:
            if self.current_user and self.current_user.username == username:
                self.current_user.end_session()
                self.current_user = None
            del self.users[username]
            self.save_users()
            print(f"{Fore.GREEN}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} —É–¥–∞–ª—ë–Ω!")
        else:
            print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!")

    def show_all_profiles(self):
        if not self.users:
            print(dynamic_border(f"{Fore.RED}–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!", Fore.RED))
            return
            
        profiles = [f"{i+1}. {self.users[un].get_styled_username()}" for i, un in enumerate(self.users.keys())]
        content = [f"{Fore.CYAN}–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:"] + profiles
        print(dynamic_border('\n'.join(content), Fore.BLUE))

    def slots(self, bet):
        if not self._validate_bet(bet):
            return

        actual_bet = bet
        used_free_spin = False
    
        if self.current_user.free_spins > 0:
            print(f"{Fore.GREEN}–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–ø–∏–Ω (–æ—Å—Ç–∞–ª–æ—Å—å: {self.current_user.free_spins-1})\n")
            self.current_user.free_spins -= 1
            actual_bet = bet
            used_free_spin = True
        else:
            self._update_balance(-bet)

        print(dynamic_border(f"{Fore.CYAN}EXTRACT SLOTS", Fore.CYAN))

        symbols = [
            ("üçí", 0.3),
            ("üçä", 0.25),
            ("üçã", 0.2),
            ("üîî", 0.15),
            ("‚≠ê", 0.07),
            ("üíé", 0.03)
        ]
    
        def spin_animation():
            for _ in range(10):
                temp = random.choices([s[0] for s in symbols],
                                      weights=[s[1] for s in symbols],
                                    k=3)
                print("\r" + " | ".join(temp), end='', flush=True)
                time.sleep(0.1)
    
        print("–í—Ä–∞—â–µ–Ω–∏–µ...")
        spin_animation()
    
        results = random.choices([s[0] for s in symbols], 
                                weights=[s[1] for s in symbols], 
                                k=3)
    
        print(" \r" + " | ".join(results) + "   ")
    
        win = 0
        free_spins_won = 0
    
        if results.count("üíé") == 3:
            win = bet * 50
            free_spins_won = 5
            print(dynamic_border(f"{Fore.GREEN}‚ú® –î–ñ–ï–ö–ü–û–¢! 3 –ê–õ–ú–ê–ó–ê! ‚ú® +{win}{CURRENCY} + {free_spins_won} –§–†–ò–°–ü–ò–ù–û–í", Fore.GREEN))
    
        elif results[0] == results[1] == results[2]:
            multiplier = 10
            if results[0] == "üîî": multiplier = 15
            if results[0] == "‚≠ê": multiplier = 20
            win = bet * multiplier
            free_spins_won = 2
            print(dynamic_border(f"{Fore.GREEN}üéâ –°–£–ü–ï–†! 3 {results[0]}! +{win}{CURRENCY} + {free_spins_won} –§–†–ò–°–ü–ò–ù–ê", Fore.GREEN))
    
        elif results[0] == results[1]:
            win = bet * 3
            if results[0] == "üíé": 
                win = bet * 10
                free_spins_won = 1
            print(dynamic_border(f"{Fore.YELLOW}–í—ã–∏–≥—Ä—ã—à –ø–æ –ª–∏–Ω–∏–∏! +{win}{CURRENCY}" + 
                                 (f" + {free_spins_won} –§–†–ò–°–ü–ò–ù" if free_spins_won else ""), 
                                 Fore.YELLOW))
    
        elif used_free_spin:
            if random.random() < 0.3:
                free_spins_won = 1
                print(dynamic_border(f"{Fore.BLUE}–£–¥–∞—á–∞ –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑! üçÄ +1 –§–†–ò–°–ü–ò–ù", Fore.BLUE))
            else:
                print(dynamic_border(f"{Fore.RED}–ü—Ä–æ–∏–≥—Ä—ã—à", Fore.RED))
    
        else:
            refund = self._apply_subscription_refund(bet)
            if refund > 0:
                print(dynamic_border(f"{Fore.RED}–ü—Ä–æ–∏–≥—Ä—ã—à {Fore.YELLOW}(–í–æ–∑–≤—Ä–∞—Ç: +{refund}{CURRENCY})", Fore.RED))
            else:
                print(dynamic_border(f"{Fore.RED}–ü—Ä–æ–∏–≥—Ä—ã—à", Fore.RED))

        if win > 0:
            win = self._apply_subscription_bonus(win)
            win = self.apply_event_bonus("slots_multiplier", win)
            self._update_balance(win)
    
        if free_spins_won > 0:
            self.current_user.free_spins += free_spins_won
            print(f"{Fore.CYAN}–¢–µ–ø–µ—Ä—å —É –≤–∞—Å {self.current_user.free_spins} —Ñ—Ä–∏—Å–ø–∏–Ω–æ–≤!")

        self._process_result(win, actual_bet)

    def trade(self, command):
        if not self.current_user:
            print(f"{Fore.RED}–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è! add/login [–Ω–∏–∫]")
            return

        try:
            parts = command.split()
            if len(parts) < 3:
                raise ValueError
            action = parts[0].lower()
            coin = parts[1].upper()
            amount = float(parts[2])

            if amount <= 0:
                print(f"{Fore.RED}–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º!")
                return

            if coin not in self.market.rates:
                print(f"{Fore.RED}–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –≤–∞–ª—é—Ç–∞: {coin}")
                return

            if action == "buy":
                cost = amount * self.market.get_rate(coin) * 1.01
                cost = self.apply_event_bonus("trade_fee", cost)
                if not self._check_balance(cost):
                    print(f"{Fore.RED}–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!")
                    return
                self._update_balance(-cost)
                self.current_user.crypto_balance[coin] += amount
                self.current_user.add_transaction('buy', coin, amount, cost)
                if "trade_xp_bonus" in self.get_current_event().get("effects", {}):
                    self.current_user.add_xp("trade", self.get_current_event()["effects"]["trade_xp_bonus"])
                print(dynamic_border(f"{Fore.GREEN}–ö—É–ø–ª–µ–Ω–æ {amount:.4f} {coin}", Fore.CYAN, 40))

            elif action == "sell":
                if self.current_user.crypto_balance.get(coin, 0) < amount:
                    print(f"{Fore.RED}–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ {coin} –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏!")
                    return
                value = amount * self.market.get_rate(coin) * 0.99
                value = self.apply_event_bonus("trade_bonus", value)
                self.current_user.crypto_balance[coin] -= amount
                self._update_balance(value)
                self.current_user.add_transaction('sell', coin, amount, value)
                print(dynamic_border(f"{Fore.GREEN}–ü—Ä–æ–¥–∞–Ω–æ {amount:.4f} {coin}", Fore.MAGENTA, 40))

            else:
                print(f"{Fore.RED}–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: {action}")
                return

            self.market.update_rates()
            self.save_users()

        except (IndexError, ValueError):
            print(f"{Fore.RED}–û—à–∏–±–∫–∞ –∫–æ–º–∞–Ω–¥—ã: trade [buy/sell] [–º–æ–Ω–µ—Ç–∞] [–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ]")

    def monster_battle(self, bet):
        if not self._validate_bet(bet):
            return

        print(dynamic_border(f"{Fore.RED}EXTRACT BATTLES", Fore.RED))
        self._update_balance(-bet)

        player_attack = random.randint(50, 150) + self.current_user.level * 2
        monster_attack = random.randint(50, 150)

        print(f"{Fore.CYAN}–í–∞—à–∞ —Å–∏–ª–∞ –∞—Ç–∞–∫–∏: {player_attack}")
        print(f"{Fore.RED}–°–∏–ª–∞ –∞—Ç–∞–∫–∏ –º–æ–Ω—Å—Ç—Ä–∞: {monster_attack}")

        if player_attack > monster_attack:
            win = bet * 3
            win = self._apply_subscription_bonus(win)
            win = self.apply_event_bonus("battle_xp", win)
            print(dynamic_border(f"{Fore.GREEN}–ü–û–ë–ï–î–ê! +{win}{CURRENCY}", Fore.GREEN))
        else:
            win = 0
            refund = self._apply_subscription_refund(bet)
            if refund > 0:
                print(dynamic_border(f"{Fore.RED}–ü–û–†–ê–ñ–ï–ù–ò–ï {Fore.YELLOW}(–í–æ–∑–≤—Ä–∞—Ç: +{refund}{CURRENCY})", Fore.RED))
            else:
                print(dynamic_border(f"{Fore.RED}–ü–û–†–ê–ñ–ï–ù–ò–ï", Fore.RED))

        self._process_result(win, bet)

    def dice(self, bet):
        if not self._validate_bet(bet):
            return

        print(dynamic_border(f"{Fore.YELLOW}EXTRACT DICE", Fore.YELLOW))
        self._update_balance(-bet)

        player_dice = sum(random.randint(1, 6) for _ in range(3))
        dealer_dice = sum(random.randint(1, 6) for _ in range(3))

        print(f"{Fore.CYAN}–í–∞—à–∏ –∫–æ—Å—Ç–∏: {player_dice}")
        print(f"{Fore.RED}–ö–æ—Å—Ç–∏ –¥–∏–ª–µ—Ä–∞: {dealer_dice}")

        if player_dice > dealer_dice:
            win = bet * 2
            win = self._apply_subscription_bonus(win)
            print(dynamic_border(f"{Fore.GREEN}–í–´–ò–ì–†–´–®! +{win}{CURRENCY}", Fore.GREEN))
        else:
            win = 0
            refund = self._apply_subscription_refund(bet)
            if refund > 0:
                print(dynamic_border(f"{Fore.RED}–ü–†–û–ò–ì–†–´–® {Fore.YELLOW}(–í–æ–∑–≤—Ä–∞—Ç: +{refund}{CURRENCY})", Fore.RED))
            else:
                print(dynamic_border(f"{Fore.RED}–ü–†–û–ò–ì–†–´–®", Fore.RED))

        self._process_result(win, bet)

    def high_low(self, bet):
        if not self._validate_bet(bet):
            return

        print(dynamic_border(f"{Fore.MAGENTA}EXTRACT HIGH-LOW", Fore.MAGENTA))
        self._update_balance(-bet)

        current = random.randint(1, 200)
        print(f"–¢–µ–∫—É—â–µ–µ —á–∏—Å–ª–æ: {Fore.CYAN}{current}")

        choice = input(f"{Fore.YELLOW}–°–ª–µ–¥—É—é—â–µ–µ –±—É–¥–µ—Ç –≤—ã—à–µ (h) –∏–ª–∏ –Ω–∏–∂–µ (l)? ").lower()
        next_num = random.randint(1, 200)
        print(f"–ù–æ–≤–æ–µ —á–∏—Å–ª–æ: {Fore.CYAN}{next_num}")

        won = (choice == 'h' and next_num > current) or (choice == 'l' and next_num < current)
        
        if won:
            base_win = bet * 2
            win = self._apply_subscription_bonus(base_win)
            win = self.apply_event_bonus("win_multiplier", win)
            print(dynamic_border(f"{Fore.GREEN}–ü–û–ë–ï–î–ê! +{win}{CURRENCY}", Fore.GREEN))
            self._process_result(win, bet)
        else:
            win = 0
            refund = self._apply_subscription_refund(bet)
            if refund > 0:
                print(dynamic_border(f"{Fore.RED}–ü–†–û–ò–ì–†–´–® {Fore.YELLOW}(–í–æ–∑–≤—Ä–∞—Ç: +{refund}{CURRENCY})", Fore.RED))
            else:
                print(dynamic_border(f"{Fore.RED}–ü–†–û–ò–ì–†–´–®", Fore.RED))
            self._process_result(0, bet)

    def show_rates(self):
        try:
            with open(CS_LOG_PATH, "r") as f:
                old_rates = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            old_rates = self.market.rates.copy()

        content = [f"{Fore.CYAN}–¢–µ–∫—É—â–∏–µ –∫—É—Ä—Å—ã:"]
        for coin, rate in self.market.rates.items():
            if coin == "EXTRACT":
                continue
            
            old_rate = old_rates.get(coin, rate)
            change = ((rate - old_rate) / old_rate) * 100 if old_rate != 0 else 0
        
            color = Fore.GREEN if change >= 0 else Fore.RED
            change_text = f"{color}({change:+.2f}%){Style.RESET_ALL}"
        
            content.append(
                f"{CRYPTO_SYMBOLS[coin]} 1 {coin} = {rate:.2f}{CURRENCY} {change_text}"
            )
    
        print(dynamic_border('\n'.join(content), Fore.BLUE))

    def rename_account(self, current_name, new_name):
        if current_name not in self.users:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å '{current_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return False

        if new_name in self.users:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –∏–º—è '{new_name}' —É–∂–µ –∑–∞–Ω—è—Ç–æ!")
            return False

        if not (new_name.isalnum() and 3 <= len(new_name) <= 16):
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –Ω–æ–≤–æ–µ –∏–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 3-16 —Å–∏–º–≤–æ–ª–æ–≤ (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã/—Ü–∏—Ñ—Ä—ã)!")
            return False

        confirm = input(
            f"{Fore.RED}–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å '{current_name}' ‚Üí '{new_name}'? (y/n): "
        ).strip().lower()

        if confirm != "y":
            print(f"{Fore.YELLOW}–û—Ç–º–µ–Ω–µ–Ω–æ.")
            return False

        user_data = self.users.pop(current_name)
        user_data.username = new_name
        self.users[new_name] = user_data

        if self.current_user and self.current_user.username == current_name:
            self.current_user = user_data

        self.save_users()
        print(f"{Fore.GREEN}–£—Å–ø–µ—Ö: '{current_name}' –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –≤ '{new_name}'!")
        return True

    def transfer(self, sender, receiver, currency, amount):
        if not isinstance(sender, str) or not isinstance(receiver, str) or not isinstance(currency, str):
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
            return False

        currency = currency.upper()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        if sender not in self.users:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å '{sender}' –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return False
            
        if receiver not in self.users:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –ø–æ–ª—É—á–∞—Ç–µ–ª—å '{receiver}' –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return False
            
        if currency not in CRYPTO_SYMBOLS:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –≤–∞–ª—é—Ç–∞ '{currency}' –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!")
            return False

        try:
            amount = round(float(amount), 8)
            if amount <= 0:
                print(f"{Fore.RED}–û—à–∏–±–∫–∞: —Å—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0!")
                return False
        except (ValueError, TypeError):
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã!")
            return False

        sender_balance = round(self.users[sender].crypto_balance.get(currency, 0), 8)
        if sender_balance < amount:
            print(f"{Fore.RED}–û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤! –î–æ—Å—Ç—É–ø–Ω–æ: {sender_balance:.8f}{CRYPTO_SYMBOLS[currency]}")
            return False

        commission_rate = 0.00 if self.users[sender].has_active_subscription() else 0.05
        commission = round(amount * commission_rate, 8)
        received_amount = round(amount - commission, 8)

        confirm_text = f"""
{Fore.CYAN}{"‚ïê"*50}
{Fore.YELLOW}–ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï –ü–ï–†–ï–í–û–î–ê
{Fore.CYAN}{"."*50}
{Fore.WHITE}‚ñ™ –û—Ç: {Fore.GREEN}{sender:<44}
{Fore.WHITE}‚ñ™ –ö–æ–º—É: {Fore.GREEN}{receiver:<42}
{Fore.WHITE}‚ñ™ –í–∞–ª—é—Ç–∞: {Fore.GREEN}{currency} {CRYPTO_SYMBOLS[currency]:<36}
{Fore.CYAN}{"‚ïê"*50}
{Fore.WHITE}‚ñ™ –°—É–º–º–∞: {Fore.GREEN}{amount:.8f}
{Fore.WHITE}‚ñ™ –ö–æ–º–∏—Å—Å–∏—è: {Fore.RED}{commission:.8f} ({commission_rate*100}%){" [–ë–µ–∑ –∫–æ–º–∏—Å—Å–∏–∏]" if commission_rate == 0 else ""}
{Fore.WHITE}‚ñ™ –ü–æ–ª—É—á–∏—Ç: {Fore.YELLOW}{received_amount:.8f}
{Fore.CYAN}{"^"*50}
{Style.BRIGHT}–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥? (yes/no): {Style.RESET_ALL}"""
        
        print(confirm_text)
        confirm = input(">>> ").strip().lower()
        
        if confirm != 'yes':
            print(f"{Fore.YELLOW}‚ùå –ü–µ—Ä–µ–≤–æ–¥ –æ—Ç–º–µ–Ω—ë–Ω")
            return False

        self.users[sender].crypto_balance[currency] = round(self.users[sender].crypto_balance.get(currency, 0) - amount, 8)
        self.users[receiver].crypto_balance[currency] = round(self.users[receiver].crypto_balance.get(currency, 0) + received_amount, 8)

        if not hasattr(self.users[sender], 'transactions'):
            self.users[sender].transactions = []
        if not hasattr(self.users[receiver], 'transactions'):
            self.users[receiver].transactions = []
            
        self.users[sender].transactions.insert(0, {
            "timestamp": timestamp,
            "action": "transfer_out",
            "coin": currency,
            "amount": -amount,
            "total": amount,
            "to": receiver,
            "commission": commission
        })
        
        self.users[receiver].transactions.insert(0, {
            "timestamp": timestamp,
            "action": "transfer_in",
            "coin": currency,
            "amount": received_amount,
            "total": received_amount,
            "from": sender
        })
        
        self.users[sender].transactions = self.users[sender].transactions[:20]
        self.users[receiver].transactions = self.users[receiver].transactions[:20]
        
        self._save_receipt({
            "timestamp": timestamp,
            "sender": sender,
            "receiver": receiver,
            "currency": currency,
            "amount": amount,
            "commission": commission,
            "received": received_amount
        })
        
        self.save_users()
        print(f"{Fore.GREEN}‚úÖ –£—Å–ø–µ—à–Ω–æ: {received_amount:.8f}{CRYPTO_SYMBOLS[currency]} ‚Üí {receiver}")
        return True

    def show_receipts(self):
        try:
            if not os.path.exists(RECEIPTS_PATH):
                print(dynamic_border(f"{Fore.YELLOW}–ò—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –ø—É—Å—Ç–∞", Fore.YELLOW))
                return

            with open(RECEIPTS_PATH, 'r', encoding='utf-8') as f:
                receipts = json.load(f)

            if not receipts:
                print(dynamic_border(f"{Fore.YELLOW}–ò—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –ø—É—Å—Ç–∞", Fore.YELLOW))
                return

            content = [f"{Fore.CYAN}–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã:"]
            for i, receipt in enumerate(receipts[:5], 1):
                content.append(
                    f"{Fore.WHITE}{i}. {receipt['timestamp'][:16]} "
                    f"{Fore.YELLOW}{receipt['sender']} ‚Üí {receipt['receiver']} "
                    f"{Fore.GREEN}{receipt['amount']:.8f}{CRYPTO_SYMBOLS.get(receipt['currency'], '?')} "
                    f"{Fore.RED}(–∫–æ–º–∏—Å—Å–∏—è: {receipt['commission']:.8f})"
                )

            print(dynamic_border('\n'.join(content), Fore.BLUE))

        except Exception as e:
            print(dynamic_border(f"{Fore.RED}–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ –ø–µ—Ä–µ–≤–æ–¥–æ–≤: {str(e)}", Fore.RED))

    def _save_receipt(self, receipt_data):
        try:
            os.makedirs(os.path.dirname(RECEIPTS_PATH), exist_ok=True)
            receipts = []
        
            if os.path.exists(RECEIPTS_PATH):
                try:
                    with open(RECEIPTS_PATH, 'r', encoding='utf-8') as f:
                        receipts = json.load(f)
                        if not isinstance(receipts, list):
                            receipts = []
                except (json.JSONDecodeError, IOError):
                    receipts = []
        
            receipts.insert(0, receipt_data)
            receipts = receipts[:10]
        
            with open(RECEIPTS_PATH, 'w', encoding='utf-8') as f:
                json.dump(receipts, f, indent=4, ensure_ascii=False, sort_keys=True)
            
        except Exception as e:
            print(f"{Fore.YELLOW}‚ö† –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —á–µ–∫–∞: {str(e)}")

    def check_user(self, username):
        if username not in self.users:
            print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å '{username}' –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return
    
        user = self.users[username]
        content = [
            f"{Fore.CYAN}–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ: {user.get_styled_username()}",
            f"{Fore.GREEN}–ë–∞–ª–∞–Ω—Å: {user.crypto_balance.get('EXTRACT', 0):.2f} {CURRENCY}",
            f"{Fore.BLUE}–£—Ä–æ–≤–µ–Ω—å: {user.level}",
            f"{Fore.YELLOW}–û–ø—ã—Ç: {user.xp}/{user.required_xp()} ({user.show_level_progress()})"
        ]
    
        top_coins = sorted(
            [(k, v) for k, v in user.crypto_balance.items() if v > 0 and k != "EXTRACT"],
            key=lambda x: x[1],
            reverse=True
        )[:3]
    
        if top_coins:
            content.append(f"{Fore.MAGENTA}–¢–æ–ø –∞–∫—Ç–∏–≤—ã:")
            for coin, amount in top_coins:
                content.append(f"  {CRYPTO_SYMBOLS[coin]} {coin}: {amount:.4f}")
    
        print(dynamic_border('\n'.join(content), Fore.CYAN))

    def global_stats(self):
        total_balance = sum(u.crypto_balance.get("EXTRACT", 0) for u in self.users.values())
        print(dynamic_border(
            f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(self.users)}\n"
            f"üí∞ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å: {total_balance:,} {CURRENCY}\n"
            f"üéÆ –í—Å–µ–≥–æ –∏–≥—Ä: {sum(u.games_played for u in self.users.values())}",
            Fore.CYAN
        ))

    def show_eup_info(self):
        info = f"""
    {Fore.CYAN}‚ïî{'‚ïê'*35}‚ïó
    ‚ïë{'–ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ü–û–î–ü–ò–°–ö–ê–•'.center(35)}‚ïë
    ‚ï†{'‚ïê'*35}‚ï£
    ‚ïë {Fore.BLUE}EUP (Extract User Privilege){Fore.CYAN}      ‚ïë
    ‚ïë ‚ñ™ –¶–µ–Ω–∞: 10 BTC/–¥–µ–Ω—å               ‚ïë
    ‚ïë ‚ñ™ –ë–æ–Ω—É—Å—ã:                         ‚ïë
    ‚ïë   +10% –∫ –≤—ã–∏–≥—Ä—ã—à–∞–º                ‚ïë
    ‚ïë   +10% —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ    ‚ïë
    ‚ïë   –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å 1,000,000‚í∫     ‚ïë
    ‚ï†{'‚îÄ'*35}‚ï£
    ‚ïë {Fore.YELLOW}EUP+ (Extract User Privilege+){Fore.CYAN}    ‚ïë
    ‚ïë ‚ñ™ –¶–µ–Ω–∞: 15 BTC/–¥–µ–Ω—å               ‚ïë
    ‚ïë ‚ñ™ –ë–æ–Ω—É—Å—ã:                         ‚ïë
    ‚ïë   +25% –∫ –≤—ã–∏–≥—Ä—ã—à–∞–º                ‚ïë
    ‚ïë   +20% —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ    ‚ïë
    ‚ïë   –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å 2,000,000‚í∫     ‚ïë
    ‚ïë   –®–∞–Ω—Å –ø–æ–ª—É—á–∏—Ç—å 10 BTC            ‚ïë
    ‚ïö{'‚ïê'*35}‚ïù
    {Style.RESET_ALL}
    {Fore.CYAN}–î–ª—è –ø–æ–∫—É–ø–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:
    {Fore.BLUE}eup buy [–¥–Ω–∏]      - –∫—É–ø–∏—Ç—å EUP
    {Fore.CYAN}–∏–ª–∏
    {Fore.YELLOW}eup_plus buy [–¥–Ω–∏] - –∫—É–ø–∏—Ç—å EUP+
    """
        print(info)

    def newnote_up(self):
        path_text = f"""
{Fore.CYAN}{VERSION_ALL}\n
{Fore.WHITE}1. –ê–Ω–∏–º–∞—Ü–∏–∏ –≤ —Å–ª–æ—Ç–∞—Ö.
{Fore.WHITE}2. –§—Ä–∏—Å–ø–∏–Ω—ã (–°–ª–æ—Ç—ã).
{Fore.WHITE}3. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–≥–æ–≤ –≤ —Å–µ–∑–æ–Ω–∞—Ö.
{Fore.WHITE}4. –û–±–Ω–æ–≤–∏–ª–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç.
{Fore.WHITE}5. –î–æ–±–∞–≤–∏–ª–∏ —Ñ–æ—Ä—É–º.
{Fore.RED}___\n
        """
        print(dynamic_border(path_text.strip(), Fore.CYAN)) 

    def display_help(self):
        help_text = f"""
{Fore.CYAN}–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
{Fore.WHITE}           ---–ê–∫–∫–∞—É–Ω—Ç---\n
{Fore.GREEN}add    [–Ω–∏–∫]                {Fore.WHITE}- –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
{Fore.GREEN}login  [–Ω–∏–∫]                {Fore.WHITE}- –í—ã–±—Ä–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
{Fore.GREEN}all                         {Fore.WHITE}- –í—Å–µ –ø—Ä–æ—Ñ–∏–ª–∏
{Fore.GREEN}rename [—Å—Ç–∞—Ä—ã–π –Ω–∏–∫] [–Ω–æ–≤—ã–π –Ω–∏–∫]{Fore.WHITE}- –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
{Fore.GREEN}transfer [–æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å] [–ø–æ–ª—É—á–∞—Ç–µ–ª—å] [–≤–∞–ª—é—Ç–∞] [—Å—É–º–º–∞] - –°–æ–≤–µ—Ä—à–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥
{Fore.GREEN}receipts                    {Fore.WHITE}- –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã
{Fore.GREEN}delete [–Ω–∏–∫]                {Fore.WHITE}- –£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
{Fore.GREEN}check [–Ω–∏–∫]                 {Fore.WHITE}- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
{Fore.GREEN}show                        {Fore.WHITE}- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è
{Fore.GREEN}level                       {Fore.WHITE}- –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Ä–æ–≤–Ω–µ
{Fore.GREEN}exit -a                     {Fore.WHITE}- –í—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞\n
{Fore.WHITE}      ---–ü–æ–∫—É–ø–∫–∞ –∏ —Å—Ç–∞—Ç—É—Å EUP---\n
{Fore.YELLOW}eup buy [–¥–Ω–∏]              {Fore.WHITE}- –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É EUP
{Fore.YELLOW}eup_plus buy [–¥–Ω–∏]         {Fore.WHITE}- –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É EUP+
{Fore.YELLOW}eup status                 {Fore.WHITE}- –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏
{Fore.YELLOW}eup info                   {Fore.WHITE}- –ê–∫—Ç—É–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –ø–æ–¥–ø–∏—Å–∫–∞—Ö
{Fore.YELLOW}eup autonone               {Fore.WHITE}- –û—Ç–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ\n
{Fore.WHITE}             ---–ò–≥—Ä—ã---\n
{Fore.RED}slots [—Å—É–º–º–∞]                 {Fore.WHITE}- –ò–≥—Ä–∞—Ç—å –≤ –∞–≤—Ç–æ–º–∞—Ç—ã
{Fore.RED}battle [—Å—É–º–º–∞]                {Fore.WHITE}- –°—Ä–∞–∑–∏—Ç—å—Å—è —Å –º–æ–Ω—Å—Ç—Ä–æ–º
{Fore.RED}dice [—Å—É–º–º–∞]                  {Fore.WHITE}- –ò–≥—Ä–∞ –≤ –∫–æ—Å—Ç–∏
{Fore.RED}highlow [—Å—É–º–º–∞]               {Fore.WHITE}- –ò–≥—Ä–∞ High-Low\n
{Fore.WHITE}         ---–ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞---\n
{Fore.BLUE}trade buy [–º–æ–Ω–µ—Ç–∞] [–∫–æ–ª-–≤–æ]  {Fore.WHITE}- –ö—É–ø–∏—Ç—å –∫—Ä–∏–ø—Ç—É
{Fore.BLUE}trade sell [–º–æ–Ω–µ—Ç–∞] [–∫–æ–ª-–≤–æ] {Fore.WHITE}- –ü—Ä–æ–¥–∞—Ç—å –∫—Ä–∏–ø—Ç—É
{Fore.BLUE}rates                        {Fore.WHITE}- –ü–æ–∫–∞–∑–∞—Ç—å –∫—É—Ä—Å—ã –æ–±–º–µ–Ω–∞
{Fore.BLUE}wal                          {Fore.WHITE}- –ü–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å –≤—Å–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞\n
{Fore.WHITE}       ---–ò–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è---\n
{Fore.WHITE}monthly                     {Fore.WHITE}- –¢–µ–∫—É—â–µ–µ –º–µ—Å—è—á–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ
{Fore.WHITE}promo [–∫–æ–¥]                {Fore.WHITE}- –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥\n
{Fore.WHITE}          ---–û–± Extract---\n
{Fore.CYAN}extract                      {Fore.WHITE}- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ—Ä—Å–∏–∏
{Fore.CYAN}wnew                         {Fore.WHITE}- –ü–∞—Ç—á–Ω–æ—É—Ç
{Fore.CYAN}forum                        {Fore.WHITE}- –û—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ñ–æ—Ä—É–º\n
{Fore.WHITE}            ---–ü—Ä–æ—á–µ–µ---\n
{Fore.MAGENTA}global                    {Fore.WHITE}- –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—Å–µ—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤
{Fore.MAGENTA}exit                      {Fore.WHITE}- –í—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã
{Fore.MAGENTA}help                      {Fore.WHITE}- –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º\n
        """
        print(dynamic_border(help_text.strip(), Fore.CYAN))

    def display_version(self):
        print_art()
        version_info = f"""
{Fore.YELLOW}{ADDINFO}
{Fore.YELLOW}{VERSION_ALL}\n
{Fore.RED}{INFO}
{Fore.RED}–ê–≤—Ç–æ—Ä—ã: Rexamm1t, Wefol1x
{Fore.RED}Telegram: @rexamm1t, @wefolix\n
{Fore.GREEN}–õ–∏—Ü–µ–Ω–∑–∏—è: MIT
        """
        print(dynamic_border(version_info.strip(), Fore.BLUE))

    def check_autosave(self):
        if time.time() - self.last_save > AUTOSAVE_INTERVAL:
            self.save_users()
            self.last_save = time.time()

def main():
    print_art()
    casino = Casino()

    try:
        while True:
            casino.check_autosave()
            current_time = datetime.now().strftime("%H:%M:%S")
            
            if casino.current_user:
                username = casino.current_user.get_styled_username()
                balance = casino.current_user.crypto_balance.get("EXTRACT", 0)
                prompt = (
                    f"{Fore.BLUE}‚ï≠‚îÄ{Fore.BLUE}[{current_time}] - {username}{Fore.BLUE} - {Fore.GREEN}{balance:.2f} {CURRENCY}\n"
                    f"{Fore.BLUE}‚ï∞‚îÄ{gradient_text('‚û§', [Fore.GREEN, Fore.YELLOW])} {Style.RESET_ALL}"
                )
            else:
                prompt = f"{Fore.BLUE}‚ï≠‚îÄ[{current_time}] - {VERSION_ALL} - –ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å? - help\n‚ï∞‚îÄ‚û§ {Style.RESET_ALL}"

            try:
                action = input(prompt).strip()
                casino.last_command = action.split()[0] if action else ""

                if action.startswith("add "):
                    username = action.split(" ", 1)[1]
                    casino.create_user(username)

                elif action.startswith("login "):
                    username = action.split(" ", 1)[1]
                    casino.select_user(username)

                elif action.startswith("check "):
                    try:
                        username = action.split(" ", 1)[1]
                        casino.check_user(username)
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: check [–Ω–∏–∫]")

                elif action.startswith("transfer "):
                    try:
                        parts = action.split()
                        if len(parts) != 5:
                            raise ValueError
                        
                        sender = parts[1]
                        receiver = parts[2]
                        currency = parts[3].upper()
                        amount = parts[4]
                    
                        if not casino.transfer(sender, receiver, currency, amount):
                            print(f"{Fore.YELLOW}–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω")
                        
                    except ValueError:
                        print(f"{Fore.RED}–û—à–∏–±–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'transfer <–æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å> <–ø–æ–ª—É—á–∞—Ç–µ–ª—å> <–≤–∞–ª—é—Ç–∞> <—Å—É–º–º–∞>'")

                elif action == "receipts":
                    casino.show_receipts()

                elif action.startswith("rename "):
                    parts = action.split()
                    if len(parts) != 3:
                        print(f"{Fore.RED}–û—à–∏–±–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `rename <—Å—Ç–∞—Ä–æ–µ_–∏–º—è> <–Ω–æ–≤–æ–µ_–∏–º—è>`")
                        continue
        
                    current_name = parts[1]
                    new_name = parts[2]

                    if current_name == new_name:
                        print(f"{Fore.YELLOW}–û—à–∏–±–∫–∞: –Ω–æ–≤–æ–µ –∏–º—è –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º!")
                        continue
        
                    if not (current_name.isprintable() and new_name.isprintable()):
                        print(f"{Fore.RED}–û—à–∏–±–∫–∞: –∏–º–µ–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã!")
                        continue
        
                    casino.rename_account(current_name, new_name)

                elif action.startswith("delete "):
                    username = action.split(" ", 1)[1]
                    casino.delete_user(username)

                elif action == "exit -a":
                    if casino.current_user:
                        casino.current_user.end_session()
                    casino.current_user = None
                    print(f"{Fore.GREEN}–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞")

                elif action.startswith("slots"):
                    try:
                        bet = float(action.split()[1])
                        casino.slots(bet)
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: slots [—Å—É–º–º–∞]")

                elif action.startswith("battle"):
                    try:
                        bet = float(action.split()[1])
                        casino.monster_battle(bet)
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: battle [—Å—É–º–º–∞]")

                elif action.startswith("dice"):
                    try:
                        bet = float(action.split()[1])
                        casino.dice(bet)
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: dice [—Å—É–º–º–∞]")

                elif action.startswith("highlow"):
                    try:
                        bet = float(action.split()[1])
                        casino.high_low(bet)
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: highlow [—Å—É–º–º–∞]")

                elif action.startswith("trade"):
                    casino.trade(action[5:])

                elif action == "global":
                    casino.global_stats()

                elif action == "eup info":
                    casino.show_eup_info()

                elif action == "rates":
                    casino.show_rates()

                elif action == "show":
                    if casino.current_user:
                        casino.current_user.show_stats()
                    else:
                        print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω! –ó–∞–≥—Ä—É–∑–∏—Ç–µ—Å—å –≤ –∞–∫–∫–∞—É–Ω—Ç.")

                elif action == "level":
                    if casino.current_user:
                        content = [
                            f"{Fore.CYAN}–£—Ä–æ–≤–µ–Ω—å: {casino.current_user.level}",
                            f"{Fore.BLUE}–û–ø—ã—Ç: {casino.current_user.xp:.0f}/{casino.current_user.required_xp():.0f}",
                            casino.current_user.show_level_progress(),
                            f"{Fore.GREEN}–í—Å–µ–≥–æ –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {casino.current_user.total_earned:.2f}{CURRENCY}"
                        ]
                        print(dynamic_border('\n'.join(content), Fore.YELLOW))
                    else:
                        print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω!")

                elif action == "monthly":
                    casino.show_monthly_event()

                elif action == "wal":
                    if casino.current_user:
                        casino.current_user.crywall()
                    else:
                        print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω!")

                elif action == "extract":
                    casino.display_version()

                elif action == "forum":
                    casino.forum.show_forum()

                elif action == "wnew":
                    casino.newnote_up()

                elif action == "help":
                    casino.display_help()

                elif action.startswith("promo "):
                    code = action.split(" ", 1)[1].strip()
                    casino.activate_promo(code)

                elif action == "all":
                    casino.show_all_profiles()

                elif action.startswith("eup buy"):
                    try:
                        days = int(action.split()[2])
                        if casino.current_user:
                            casino.current_user.buy_eup(days)
                        else:
                            print(f"{Fore.RED}–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç!")
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: eup buy [–¥–Ω–∏]")

                elif action.startswith("eup_plus buy"):
                    try:
                        days = int(action.split()[2])
                        if casino.current_user:
                            casino.current_user.buy_eup_plus(days)
                        else:
                            print(f"{Fore.RED}–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç!")
                    except:
                        print(f"{Fore.RED}–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: eup_plus buy [–¥–Ω–∏]")

                elif action == "eup status":
                    if casino.current_user:
                        casino.current_user.eup_status()
                    else:
                        print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω!")

                elif action == "eup autonone":
                    if casino.current_user:
                        casino.current_user.eup_autonone()
                    else:
                        print(f"{Fore.RED}–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω!")

                elif action == "exit":
                    if casino.current_user:
                        casino.current_user.end_session()
                    casino.save_users()
                    print(gradient_text("\n–î–æ –≤—Å—Ç—Ä–µ—á–∏! –í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω.\n", [Fore.GREEN, Fore.BLUE]))
                    break
                
                else:
                    print(f"{Fore.RED}–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –í–≤–µ–¥–∏—Ç–µ 'help' –¥–ª—è –ø–æ–º–æ—â–∏")

            except (IndexError, ValueError) as e:
                print(f"{Fore.RED}–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞: {str(e)}")
            except Exception as e:
                print(f"{Fore.RED}–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}")

    except KeyboardInterrupt:
        print(f"{Fore.RED}\n–°—Ä–æ—á–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...")
        if casino.current_user:
            casino.current_user.end_session()
        casino.save_users()
        exit()

if __name__ == "__main__":
    if not os.path.exists('/etc'):
        os.makedirs('/etc', exist_ok=True)
    main()
